Below is a complete, production-style Next.js + Tailwind project structure for the Interactive Book Library Application with JSON Server CRUD, search by title/author, grid/list toggle, add/edit with validation, delete confirmation, responsive UI, loading and error states, and reusable components as requested. This matches the challenge requirements (core features + technical + UI layout).  ￼  ￼

⸻

Tech stack
	•	Next.js (App Router) + TypeScript
	•	Tailwind CSS
	•	TanStack Query for server-state + caching
	•	React Hook Form + Zod for add/edit validation
	•	Small reusable UI components (Button, Input, Modal, ConfirmDialog, etc.)

⸻

Folder structure

book-library/
  app/
    globals.css
    layout.tsx
    page.tsx
    providers.tsx
  components/
    books/
      BookCard.tsx
      BookFormModal.tsx
      BookGrid.tsx
      BookList.tsx
      BookRow.tsx
      EmptyState.tsx
      HeaderBar.tsx
      RatingStars.tsx
    ui/
      Button.tsx
      ConfirmDialog.tsx
      Dialog.tsx
      Input.tsx
      Label.tsx
      Select.tsx
      Skeleton.tsx
      Toast.tsx
  lib/
    api/
      books.ts
      client.ts
    hooks/
      useBooks.ts
    schemas/
      book.ts
    utils/
      cn.ts
      debounce.ts
  public/
    covers/
      default-cover.jpg
  db/
    db.json
  README.md
  package.json
  postcss.config.js
  tailwind.config.ts
  tsconfig.json
  next.config.ts


⸻

1) Setup commands

Create app

npx create-next-app@latest book-library --ts --tailwind --eslint --app
cd book-library

Install dependencies

npm i @tanstack/react-query react-hook-form zod @hookform/resolvers lucide-react

Add JSON Server

npm i -D json-server


⸻

2) JSON Server mock API

db/db.json

{
  "books": [
    {
      "id": 1,
      "title": "Clean Code",
      "author": "Robert C. Martin",
      "category": "Software",
      "rating": 4.6,
      "coverUrl": "/covers/default-cover.jpg"
    },
    {
      "id": 2,
      "title": "The Pragmatic Programmer",
      "author": "Andrew Hunt, David Thomas",
      "category": "Software",
      "rating": 4.7,
      "coverUrl": "/covers/default-cover.jpg"
    },
    {
      "id": 3,
      "title": "Atomic Habits",
      "author": "James Clear",
      "category": "Self-Help",
      "rating": 4.5,
      "coverUrl": "/covers/default-cover.jpg"
    }
  ]
}

Add scripts in package.json

{
  "scripts": {
    "dev": "next dev",
    "server": "json-server --watch db/db.json --port 4001",
    "dev:all": "npm run server & npm run dev"
  }
}

Run:

npm run dev:all

API:
	•	GET http://localhost:4001/books
	•	POST http://localhost:4001/books
	•	PATCH http://localhost:4001/books/:id
	•	DELETE http://localhost:4001/books/:id

⸻

3) Environment variable

.env.local

NEXT_PUBLIC_API_URL=http://localhost:4001


⸻

4) Core code

app/layout.tsx

import "./globals.css";
import type { Metadata } from "next";
import { Providers } from "./providers";

export const metadata: Metadata = {
  title: "Book Library",
  description: "Interactive Book Library Application"
};

export default function RootLayout({ children }: { children: React.ReactNode }) {
  return (
    <html lang="en">
      <body className="min-h-screen bg-zinc-950 text-zinc-50 antialiased">
        <Providers>{children}</Providers>
      </body>
    </html>
  );
}

app/providers.tsx

"use client";

import * as React from "react";
import { QueryClient, QueryClientProvider } from "@tanstack/react-query";
import { ToastProvider } from "@/components/ui/Toast";

export function Providers({ children }: { children: React.ReactNode }) {
  const [client] = React.useState(
    () =>
      new QueryClient({
        defaultOptions: {
          queries: { retry: 1, refetchOnWindowFocus: false }
        }
      })
  );

  return (
    <QueryClientProvider client={client}>
      <ToastProvider>{children}</ToastProvider>
    </QueryClientProvider>
  );
}

app/page.tsx

"use client";

import * as React from "react";
import { HeaderBar } from "@/components/books/HeaderBar";
import { BookGrid } from "@/components/books/BookGrid";
import { BookList } from "@/components/books/BookList";
import { useBooks } from "@/lib/hooks/useBooks";
import { Skeleton } from "@/components/ui/Skeleton";
import { EmptyState } from "@/components/books/EmptyState";

export type ViewMode = "grid" | "list";

export default function Page() {
  const [view, setView] = React.useState<ViewMode>("grid");
  const [query, setQuery] = React.useState("");
  const { data, isLoading, isError, error } = useBooks();

  const books = React.useMemo(() => {
    const q = query.trim().toLowerCase();
    if (!q) return data ?? [];
    return (data ?? []).filter((b) => {
      return (
        b.title.toLowerCase().includes(q) ||
        b.author.toLowerCase().includes(q)
      );
    });
  }, [data, query]);

  return (
    <div className="mx-auto w-full max-w-6xl px-4 py-8">
      <HeaderBar view={view} onViewChange={setView} query={query} onQueryChange={setQuery} />

      <div className="mt-6">
        {isLoading && (
          <div className="grid grid-cols-1 gap-4 sm:grid-cols-2 lg:grid-cols-3">
            {Array.from({ length: 6 }).map((_, i) => (
              <Skeleton key={i} className="h-[220px] rounded-2xl" />
            ))}
          </div>
        )}

        {isError && (
          <div className="rounded-2xl border border-red-500/30 bg-red-500/10 p-4 text-red-100">
            <p className="font-medium">Something went wrong</p>
            <p className="mt-1 text-sm text-red-100/80">
              {error instanceof Error ? error.message : "Failed to load books."}
            </p>
          </div>
        )}

        {!isLoading && !isError && books.length === 0 && (
          <EmptyState />
        )}

        {!isLoading && !isError && books.length > 0 && (
          <>
            {view === "grid" ? <BookGrid books={books} /> : <BookList books={books} />}
          </>
        )}
      </div>
    </div>
  );
}


⸻

5) API + hooks

lib/api/client.ts

const baseUrl = process.env.NEXT_PUBLIC_API_URL;

if (!baseUrl) {
  // Avoid throwing at build time in some platforms, but keep helpful messaging.
  // eslint-disable-next-line no-console
  console.warn("NEXT_PUBLIC_API_URL is not set. Set it in .env.local");
}

export async function api<T>(path: string, init?: RequestInit): Promise<T> {
  const res = await fetch(`${baseUrl}${path}`, {
    ...init,
    headers: {
      "Content-Type": "application/json",
      ...(init?.headers ?? {})
    }
  });

  if (!res.ok) {
    let msg = `Request failed (${res.status})`;
    try {
      const body = await res.json();
      msg = body?.message ?? msg;
    } catch {
      // ignore
    }
    throw new Error(msg);
  }

  // json-server returns empty on delete sometimes
  const text = await res.text();
  return (text ? JSON.parse(text) : null) as T;
}

lib/api/books.ts

import { api } from "./client";
import type { Book, BookCreateInput, BookUpdateInput } from "@/lib/schemas/book";

export function fetchBooks() {
  return api<Book[]>("/books", { cache: "no-store" });
}

export function createBook(payload: BookCreateInput) {
  return api<Book>("/books", { method: "POST", body: JSON.stringify(payload) });
}

export function updateBook(id: number, payload: BookUpdateInput) {
  return api<Book>(`/books/${id}`, { method: "PATCH", body: JSON.stringify(payload) });
}

export function deleteBook(id: number) {
  return api<null>(`/books/${id}`, { method: "DELETE" });
}

lib/hooks/useBooks.ts

import { useMutation, useQuery, useQueryClient } from "@tanstack/react-query";
import { createBook, deleteBook, fetchBooks, updateBook } from "@/lib/api/books";
import type { BookCreateInput, BookUpdateInput } from "@/lib/schemas/book";

export function useBooks() {
  return useQuery({
    queryKey: ["books"],
    queryFn: fetchBooks
  });
}

export function useCreateBook() {
  const qc = useQueryClient();
  return useMutation({
    mutationFn: (payload: BookCreateInput) => createBook(payload),
    onSuccess: async () => {
      await qc.invalidateQueries({ queryKey: ["books"] });
    }
  });
}

export function useUpdateBook() {
  const qc = useQueryClient();
  return useMutation({
    mutationFn: ({ id, payload }: { id: number; payload: BookUpdateInput }) =>
      updateBook(id, payload),
    onSuccess: async () => {
      await qc.invalidateQueries({ queryKey: ["books"] });
    }
  });
}

export function useDeleteBook() {
  const qc = useQueryClient();
  return useMutation({
    mutationFn: (id: number) => deleteBook(id),
    onSuccess: async () => {
      await qc.invalidateQueries({ queryKey: ["books"] });
    }
  });
}


⸻

6) Schema + validation

lib/schemas/book.ts

import { z } from "zod";

export const bookSchema = z.object({
  id: z.number(),
  title: z.string().min(1),
  author: z.string().min(1),
  category: z.string().min(1),
  rating: z.number().min(0).max(5),
  coverUrl: z.string().min(1)
});

export type Book = z.infer<typeof bookSchema>;

export const bookFormSchema = z.object({
  title: z.string().min(2, "Title must be at least 2 characters"),
  author: z.string().min(2, "Author must be at least 2 characters"),
  category: z.string().min(2, "Category is required"),
  rating: z
    .number({ invalid_type_error: "Rating is required" })
    .min(0, "Min 0")
    .max(5, "Max 5"),
  coverUrl: z
    .string()
    .min(1, "Cover is required")
});

export type BookCreateInput = z.infer<typeof bookFormSchema>;
export type BookUpdateInput = Partial<BookCreateInput>;


⸻

7) Modern UI components

lib/utils/cn.ts

import { type ClassValue, clsx } from "clsx";
import { twMerge } from "tailwind-merge";

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs));
}

Install helper deps:

npm i clsx tailwind-merge

components/ui/Button.tsx

import { cn } from "@/lib/utils/cn";

type Props = React.ButtonHTMLAttributes<HTMLButtonElement> & {
  variant?: "primary" | "secondary" | "danger" | "ghost";
};

export function Button({ className, variant = "primary", ...props }: Props) {
  const base =
    "inline-flex items-center justify-center gap-2 rounded-xl px-4 py-2 text-sm font-medium transition focus:outline-none focus:ring-2 focus:ring-zinc-400/40 disabled:opacity-50 disabled:pointer-events-none";

  const variants: Record<NonNullable<Props["variant"]>, string> = {
    primary: "bg-zinc-50 text-zinc-900 hover:bg-zinc-200",
    secondary: "bg-zinc-900 text-zinc-50 border border-zinc-800 hover:bg-zinc-800",
    danger: "bg-red-500/15 text-red-100 border border-red-500/30 hover:bg-red-500/25",
    ghost: "bg-transparent text-zinc-100 hover:bg-zinc-900"
  };

  return <button className={cn(base, variants[variant], className)} {...props} />;
}

components/ui/Input.tsx

import { cn } from "@/lib/utils/cn";

export function Input({
  className,
  ...props
}: React.InputHTMLAttributes<HTMLInputElement>) {
  return (
    <input
      className={cn(
        "h-10 w-full rounded-xl border border-zinc-800 bg-zinc-950 px-3 text-sm text-zinc-50 placeholder:text-zinc-500 focus:outline-none focus:ring-2 focus:ring-zinc-400/30",
        className
      )}
      {...props}
    />
  );
}

components/ui/Label.tsx

import { cn } from "@/lib/utils/cn";

export function Label({ className, ...props }: React.LabelHTMLAttributes<HTMLLabelElement>) {
  return <label className={cn("text-sm font-medium text-zinc-200", className)} {...props} />;
}

components/ui/Dialog.tsx

"use client";

import * as React from "react";
import { cn } from "@/lib/utils/cn";

type DialogProps = {
  open: boolean;
  onOpenChange: (open: boolean) => void;
  title: string;
  children: React.ReactNode;
  footer?: React.ReactNode;
};

export function Dialog({ open, onOpenChange, title, children, footer }: DialogProps) {
  React.useEffect(() => {
    function onKey(e: KeyboardEvent) {
      if (e.key === "Escape") onOpenChange(false);
    }
    if (open) window.addEventListener("keydown", onKey);
    return () => window.removeEventListener("keydown", onKey);
  }, [open, onOpenChange]);

  if (!open) return null;

  return (
    <div className="fixed inset-0 z-50">
      <div
        className="absolute inset-0 bg-black/60 backdrop-blur-sm"
        onClick={() => onOpenChange(false)}
      />
      <div className="absolute inset-0 flex items-center justify-center p-4">
        <div
          className={cn(
            "w-full max-w-lg rounded-2xl border border-zinc-800 bg-zinc-950 shadow-xl"
          )}
          onClick={(e) => e.stopPropagation()}
        >
          <div className="flex items-center justify-between border-b border-zinc-900 px-5 py-4">
            <h2 className="text-base font-semibold">{title}</h2>
            <button
              className="rounded-lg p-2 text-zinc-400 hover:bg-zinc-900 hover:text-zinc-100"
              onClick={() => onOpenChange(false)}
              aria-label="Close"
            >
              ✕
            </button>
          </div>
          <div className="px-5 py-4">{children}</div>
          {footer ? (
            <div className="flex items-center justify-end gap-2 border-t border-zinc-900 px-5 py-4">
              {footer}
            </div>
          ) : null}
        </div>
      </div>
    </div>
  );
}

components/ui/ConfirmDialog.tsx

"use client";

import { Dialog } from "./Dialog";
import { Button } from "./Button";

type Props = {
  open: boolean;
  onOpenChange: (v: boolean) => void;
  title: string;
  description: string;
  confirmText?: string;
  isLoading?: boolean;
  onConfirm: () => void;
};

export function ConfirmDialog({
  open,
  onOpenChange,
  title,
  description,
  confirmText = "Confirm",
  isLoading,
  onConfirm
}: Props) {
  return (
    <Dialog
      open={open}
      onOpenChange={onOpenChange}
      title={title}
      footer={
        <>
          <Button variant="ghost" onClick={() => onOpenChange(false)} disabled={isLoading}>
            Cancel
          </Button>
          <Button
            variant="danger"
            onClick={onConfirm}
            disabled={isLoading}
          >
            {isLoading ? "Working..." : confirmText}
          </Button>
        </>
      }
    >
      <p className="text-sm text-zinc-300">{description}</p>
    </Dialog>
  );
}

components/ui/Skeleton.tsx

import { cn } from "@/lib/utils/cn";

export function Skeleton({ className }: { className?: string }) {
  return (
    <div
      className={cn(
        "animate-pulse bg-zinc-900/60 ring-1 ring-inset ring-zinc-800",
        className
      )}
    />
  );
}


⸻

8) Book UI (grid/list, rating stars, header, CRUD modals)

components/books/RatingStars.tsx

import { Star } from "lucide-react";

export function RatingStars({ value }: { value: number }) {
  const full = Math.floor(value);
  const hasHalf = value - full >= 0.5;

  return (
    <div className="flex items-center gap-1">
      {Array.from({ length: 5 }).map((_, i) => {
        const filled = i < full;
        const half = i === full && hasHalf;

        return (
          <div key={i} className="relative">
            <Star className={filled ? "h-4 w-4 fill-current text-zinc-100" : "h-4 w-4 text-zinc-500"} />
            {half ? (
              <Star className="absolute left-0 top-0 h-4 w-4 fill-current text-zinc-100 [clip-path:inset(0_50%_0_0)]" />
            ) : null}
          </div>
        );
      })}
      <span className="ml-1 text-xs text-zinc-400">{value.toFixed(1)}</span>
    </div>
  );
}

components/books/BookCard.tsx

"use client";

import Image from "next/image";
import type { Book } from "@/lib/schemas/book";
import { RatingStars } from "./RatingStars";
import { Button } from "@/components/ui/Button";

type Props = {
  book: Book;
  onEdit: (b: Book) => void;
  onDelete: (b: Book) => void;
};

export function BookCard({ book, onEdit, onDelete }: Props) {
  return (
    <div className="group overflow-hidden rounded-2xl border border-zinc-800 bg-zinc-950">
      <div className="relative h-36 w-full bg-zinc-900/40">
        <Image
          src={book.coverUrl}
          alt={book.title}
          fill
          className="object-cover transition duration-300 group-hover:scale-[1.02]"
          sizes="(max-width: 768px) 100vw, 33vw"
        />
      </div>

      <div className="p-4">
        <div className="flex items-start justify-between gap-3">
          <div className="min-w-0">
            <p className="truncate text-sm font-semibold">{book.title}</p>
            <p className="truncate text-xs text-zinc-400">{book.author}</p>
          </div>
          <span className="shrink-0 rounded-full border border-zinc-800 bg-zinc-900/40 px-2 py-1 text-xs text-zinc-200">
            {book.category}
          </span>
        </div>

        <div className="mt-3">
          <RatingStars value={book.rating} />
        </div>

        <div className="mt-4 flex gap-2">
          <Button variant="secondary" className="w-full" onClick={() => onEdit(book)}>
            Edit
          </Button>
          <Button variant="danger" className="w-full" onClick={() => onDelete(book)}>
            Delete
          </Button>
        </div>
      </div>
    </div>
  );
}

components/books/BookRow.tsx

"use client";

import Image from "next/image";
import type { Book } from "@/lib/schemas/book";
import { RatingStars } from "./RatingStars";
import { Button } from "@/components/ui/Button";

export function BookRow({
  book,
  onEdit,
  onDelete
}: {
  book: Book;
  onEdit: (b: Book) => void;
  onDelete: (b: Book) => void;
}) {
  return (
    <div className="flex items-center gap-4 rounded-2xl border border-zinc-800 bg-zinc-950 p-3">
      <div className="relative h-14 w-14 overflow-hidden rounded-xl border border-zinc-800 bg-zinc-900/40">
        <Image src={book.coverUrl} alt={book.title} fill className="object-cover" />
      </div>

      <div className="min-w-0 flex-1">
        <div className="flex flex-wrap items-center gap-x-3 gap-y-1">
          <p className="truncate text-sm font-semibold">{book.title}</p>
          <span className="rounded-full border border-zinc-800 bg-zinc-900/40 px-2 py-0.5 text-xs text-zinc-200">
            {book.category}
          </span>
        </div>
        <p className="truncate text-xs text-zinc-400">{book.author}</p>
        <div className="mt-1">
          <RatingStars value={book.rating} />
        </div>
      </div>

      <div className="flex shrink-0 gap-2">
        <Button variant="secondary" onClick={() => onEdit(book)}>
          Edit
        </Button>
        <Button variant="danger" onClick={() => onDelete(book)}>
          Delete
        </Button>
      </div>
    </div>
  );
}

components/books/BookGrid.tsx

"use client";

import * as React from "react";
import type { Book } from "@/lib/schemas/book";
import { BookCard } from "./BookCard";
import { BookFormModal } from "./BookFormModal";
import { ConfirmDialog } from "@/components/ui/ConfirmDialog";
import { useDeleteBook } from "@/lib/hooks/useBooks";
import { useToast } from "@/components/ui/Toast";

export function BookGrid({ books }: { books: Book[] }) {
  const [editOpen, setEditOpen] = React.useState(false);
  const [editing, setEditing] = React.useState<Book | null>(null);

  const [deleteOpen, setDeleteOpen] = React.useState(false);
  const [deleting, setDeleting] = React.useState<Book | null>(null);

  const del = useDeleteBook();
  const toast = useToast();

  function onEdit(b: Book) {
    setEditing(b);
    setEditOpen(true);
  }

  function onDelete(b: Book) {
    setDeleting(b);
    setDeleteOpen(true);
  }

  async function confirmDelete() {
    if (!deleting) return;
    try {
      await del.mutateAsync(deleting.id);
      toast.show({ title: "Deleted", message: `"${deleting.title}" removed` });
      setDeleteOpen(false);
      setDeleting(null);
    } catch (e) {
      toast.show({ title: "Delete failed", message: e instanceof Error ? e.message : "Try again." });
    }
  }

  return (
    <>
      <div className="grid grid-cols-1 gap-4 sm:grid-cols-2 lg:grid-cols-3">
        {books.map((b) => (
          <BookCard key={b.id} book={b} onEdit={onEdit} onDelete={onDelete} />
        ))}
      </div>

      <BookFormModal
        open={editOpen}
        onOpenChange={(v) => {
          setEditOpen(v);
          if (!v) setEditing(null);
        }}
        mode="edit"
        book={editing ?? undefined}
      />

      <ConfirmDialog
        open={deleteOpen}
        onOpenChange={(v) => {
          setDeleteOpen(v);
          if (!v) setDeleting(null);
        }}
        title="Delete book?"
        description={deleting ? `This will permanently remove "${deleting.title}".` : "This action cannot be undone."}
        confirmText="Delete"
        isLoading={del.isPending}
        onConfirm={confirmDelete}
      />
    </>
  );
}

components/books/BookList.tsx

"use client";

import * as React from "react";
import type { Book } from "@/lib/schemas/book";
import { BookRow } from "./BookRow";
import { BookFormModal } from "./BookFormModal";
import { ConfirmDialog } from "@/components/ui/ConfirmDialog";
import { useDeleteBook } from "@/lib/hooks/useBooks";
import { useToast } from "@/components/ui/Toast";

export function BookList({ books }: { books: Book[] }) {
  const [editOpen, setEditOpen] = React.useState(false);
  const [editing, setEditing] = React.useState<Book | null>(null);

  const [deleteOpen, setDeleteOpen] = React.useState(false);
  const [deleting, setDeleting] = React.useState<Book | null>(null);

  const del = useDeleteBook();
  const toast = useToast();

  function onEdit(b: Book) {
    setEditing(b);
    setEditOpen(true);
  }

  function onDelete(b: Book) {
    setDeleting(b);
    setDeleteOpen(true);
  }

  async function confirmDelete() {
    if (!deleting) return;
    try {
      await del.mutateAsync(deleting.id);
      toast.show({ title: "Deleted", message: `"${deleting.title}" removed` });
      setDeleteOpen(false);
      setDeleting(null);
    } catch (e) {
      toast.show({ title: "Delete failed", message: e instanceof Error ? e.message : "Try again." });
    }
  }

  return (
    <>
      <div className="flex flex-col gap-3">
        {books.map((b) => (
          <BookRow key={b.id} book={b} onEdit={onEdit} onDelete={onDelete} />
        ))}
      </div>

      <BookFormModal
        open={editOpen}
        onOpenChange={(v) => {
          setEditOpen(v);
          if (!v) setEditing(null);
        }}
        mode="edit"
        book={editing ?? undefined}
      />

      <ConfirmDialog
        open={deleteOpen}
        onOpenChange={(v) => {
          setDeleteOpen(v);
          if (!v) setDeleting(null);
        }}
        title="Delete book?"
        description={deleting ? `This will permanently remove "${deleting.title}".` : "This action cannot be undone."}
        confirmText="Delete"
        isLoading={del.isPending}
        onConfirm={confirmDelete}
      />
    </>
  );
}

components/books/HeaderBar.tsx

"use client";

import * as React from "react";
import { Button } from "@/components/ui/Button";
import { Input } from "@/components/ui/Input";
import { LayoutGrid, List, Plus } from "lucide-react";
import type { ViewMode } from "@/app/page";
import { BookFormModal } from "./BookFormModal";

type Props = {
  view: ViewMode;
  onViewChange: (v: ViewMode) => void;
  query: string;
  onQueryChange: (v: string) => void;
};

export function HeaderBar({ view, onViewChange, query, onQueryChange }: Props) {
  const [open, setOpen] = React.useState(false);

  return (
    <>
      <div className="flex flex-col gap-4 rounded-2xl border border-zinc-800 bg-zinc-950 p-4 sm:flex-row sm:items-center sm:justify-between">
        <div className="min-w-0">
          <h1 className="text-lg font-semibold">Book Library</h1>
          <p className="text-sm text-zinc-400">
            Search, add, edit, and manage your collection
          </p>
        </div>

        <div className="flex flex-col gap-3 sm:flex-row sm:items-center">
          <div className="w-full sm:w-72">
            <Input
              value={query}
              onChange={(e) => onQueryChange(e.target.value)}
              placeholder="Search by title or author..."
              aria-label="Search books"
            />
          </div>

          <div className="flex items-center gap-2">
            <Button
              variant="secondary"
              onClick={() => onViewChange(view === "grid" ? "list" : "grid")}
              aria-label="Toggle view"
            >
              {view === "grid" ? <List className="h-4 w-4" /> : <LayoutGrid className="h-4 w-4" />}
              {view === "grid" ? "List" : "Grid"}
            </Button>

            <Button onClick={() => setOpen(true)}>
              <Plus className="h-4 w-4" />
              Add Book
            </Button>
          </div>
        </div>
      </div>

      <BookFormModal open={open} onOpenChange={setOpen} mode="create" />
    </>
  );
}

components/books/BookFormModal.tsx

"use client";

import * as React from "react";
import { Dialog } from "@/components/ui/Dialog";
import { Button } from "@/components/ui/Button";
import { Input } from "@/components/ui/Input";
import { Label } from "@/components/ui/Label";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { bookFormSchema, type Book, type BookCreateInput } from "@/lib/schemas/book";
import { useCreateBook, useUpdateBook } from "@/lib/hooks/useBooks";
import { useToast } from "@/components/ui/Toast";

type Props = {
  open: boolean;
  onOpenChange: (v: boolean) => void;
  mode: "create" | "edit";
  book?: Book;
};

const DEFAULT_COVER = "/covers/default-cover.jpg";

export function BookFormModal({ open, onOpenChange, mode, book }: Props) {
  const isEdit = mode === "edit";
  const toast = useToast();

  const create = useCreateBook();
  const update = useUpdateBook();

  const form = useForm<BookCreateInput>({
    resolver: zodResolver(bookFormSchema),
    defaultValues: {
      title: "",
      author: "",
      category: "",
      rating: 4.0,
      coverUrl: DEFAULT_COVER
    }
  });

  React.useEffect(() => {
    if (!open) return;

    if (isEdit && book) {
      form.reset({
        title: book.title,
        author: book.author,
        category: book.category,
        rating: book.rating,
        coverUrl: book.coverUrl || DEFAULT_COVER
      });
    } else {
      form.reset({
        title: "",
        author: "",
        category: "",
        rating: 4.0,
        coverUrl: DEFAULT_COVER
      });
    }
  }, [open, isEdit, book, form]);

  const isPending = create.isPending || update.isPending;

  async function onSubmit(values: BookCreateInput) {
    try {
      if (isEdit && book) {
        await update.mutateAsync({ id: book.id, payload: values });
        toast.show({ title: "Updated", message: `"${values.title}" saved` });
      } else {
        await create.mutateAsync(values);
        toast.show({ title: "Added", message: `"${values.title}" added to library` });
      }
      onOpenChange(false);
    } catch (e) {
      toast.show({
        title: "Save failed",
        message: e instanceof Error ? e.message : "Please try again."
      });
    }
  }

  return (
    <Dialog
      open={open}
      onOpenChange={(v) => {
        if (!isPending) onOpenChange(v);
      }}
      title={isEdit ? "Edit Book" : "Add New Book"}
      footer={
        <>
          <Button variant="ghost" onClick={() => onOpenChange(false)} disabled={isPending}>
            Cancel
          </Button>
          <Button onClick={form.handleSubmit(onSubmit)} disabled={isPending}>
            {isPending ? "Saving..." : "Save"}
          </Button>
        </>
      }
    >
      <form className="space-y-4" onSubmit={form.handleSubmit(onSubmit)}>
        <Field label="Title" error={form.formState.errors.title?.message}>
          <Input {...form.register("title")} placeholder="e.g., Deep Work" />
        </Field>

        <Field label="Author" error={form.formState.errors.author?.message}>
          <Input {...form.register("author")} placeholder="e.g., Cal Newport" />
        </Field>

        <div className="grid grid-cols-1 gap-4 sm:grid-cols-2">
          <Field label="Category" error={form.formState.errors.category?.message}>
            <Input {...form.register("category")} placeholder="e.g., Software" />
          </Field>

          <Field label="Rating (0 to 5)" error={form.formState.errors.rating?.message}>
            <Input
              type="number"
              step="0.1"
              min={0}
              max={5}
              value={form.watch("rating")}
              onChange={(e) => form.setValue("rating", Number(e.target.value), { shouldValidate: true })}
            />
          </Field>
        </div>

        <Field label="Cover URL" error={form.formState.errors.coverUrl?.message}>
          <Input {...form.register("coverUrl")} placeholder="/covers/default-cover.jpg" />
          <p className="mt-1 text-xs text-zinc-500">
            Tip: Keep it a local path or a direct image URL.
          </p>
        </Field>

        <button type="submit" className="hidden" />
      </form>
    </Dialog>
  );
}

function Field({
  label,
  error,
  children
}: {
  label: string;
  error?: string;
  children: React.ReactNode;
}) {
  return (
    <div>
      <div className="flex items-end justify-between gap-3">
        <Label>{label}</Label>
        {error ? <span className="text-xs text-red-200">{error}</span> : null}
      </div>
      <div className="mt-2">{children}</div>
    </div>
  );
}

components/books/EmptyState.tsx

import { BookOpen } from "lucide-react";

export function EmptyState() {
  return (
    <div className="rounded-2xl border border-zinc-800 bg-zinc-950 p-8 text-center">
      <div className="mx-auto flex h-12 w-12 items-center justify-center rounded-2xl border border-zinc-800 bg-zinc-900/40">
        <BookOpen className="h-5 w-5 text-zinc-200" />
      </div>
      <h3 className="mt-4 text-base font-semibold">No books found</h3>
      <p className="mt-1 text-sm text-zinc-400">
        Try a different search, or add a new book to your library.
      </p>
    </div>
  );
}


⸻

9) Toast (small, clean UX)

components/ui/Toast.tsx

"use client";

import * as React from "react";

type ToastItem = {
  id: string;
  title: string;
  message?: string;
};

const ToastCtx = React.createContext<{ show: (t: Omit<ToastItem, "id">) => void } | null>(null);

export function ToastProvider({ children }: { children: React.ReactNode }) {
  const [items, setItems] = React.useState<ToastItem[]>([]);

  const show = React.useCallback((t: Omit<ToastItem, "id">) => {
    const id = crypto.randomUUID();
    setItems((p) => [...p, { id, ...t }]);
    window.setTimeout(() => {
      setItems((p) => p.filter((x) => x.id !== id));
    }, 2600);
  }, []);

  return (
    <ToastCtx.Provider value={{ show }}>
      {children}
      <div className="fixed bottom-4 right-4 z-[60] flex w-full max-w-sm flex-col gap-2 px-4">
        {items.map((t) => (
          <div
            key={t.id}
            className="rounded-2xl border border-zinc-800 bg-zinc-950 p-4 shadow-xl"
          >
            <p className="text-sm font-semibold">{t.title}</p>
            {t.message ? <p className="mt-1 text-sm text-zinc-400">{t.message}</p> : null}
          </div>
        ))}
      </div>
    </ToastCtx.Provider>
  );
}

export function useToast() {
  const ctx = React.useContext(ToastCtx);
  if (!ctx) throw new Error("useToast must be used within ToastProvider");
  return ctx;
}


⸻

10) Tailwind base (already created by Next)

Your app/globals.css should have Tailwind directives. Example:

@tailwind base;
@tailwind components;
@tailwind utilities;

:root {
  color-scheme: dark;
}


⸻

README.md (copy)

# Interactive Book Library (Next.js + Tailwind)

## Features
- Fetch, display books with cover, title, author, rating, category
- Search by title or author
- Add new books (validated)
- Edit existing books (validated)
- Delete with confirmation
- Toggle Grid/List view
- Responsive design + loading skeletons + error states

## Tech
Next.js (App Router), TypeScript, Tailwind, TanStack Query, React Hook Form, Zod, JSON Server.

## Setup
1) Install
npm install

2) Start mock API (JSON Server)
npm run server
API runs at http://localhost:4001

3) Start Next.js
npm run dev

Or run both:
npm run dev:all

## Env
Create .env.local:
NEXT_PUBLIC_API_URL=http://localhost:4001


⸻

If you want, I can also add:
	•	category filter chips dropdown
	•	client-side pagination
	•	optimistic updates for edit/delete
	•	a nicer cover picker (local presets) without changing the API

All of that stays within the original requirements for UI layout and CRUD + JSON Server.  ￼